h05480
s 00001/00001/00598
d D 2.33 92/08/23 11:32:15 rsb 44 43
c Return from Warsaw
e
s 00001/00001/00598
d D 2.32 92/02/02 12:29:58 rsb 43 42
c Address
e
s 00003/00000/00596
d D 2.31 92/02/02 11:44:28 rsb 42 41
c Inserted copyright
e
s 00001/00001/00595
d D 2.30 91/08/16 10:16:43 rsb 41 40
c 
e
s 00004/00004/00592
d D 2.29 91/08/06 20:39:51 rsb 40 39
c 
e
s 00015/00025/00581
d D 2.28 91/08/06 20:25:14 rsb 39 38
c from DOS
e
s 00009/00008/00597
d D 2.27 91/08/06 13:15:37 rsb 38 37
c help changes
e
s 00002/00002/00603
d D 2.26 91/08/05 13:44:03 rsb 37 36
c cliff.c
e
s 00065/00011/00540
d D 2.25 91/08/02 11:37:34 rsb 36 35
c included spatial and estimate
e
s 00000/00000/00551
d D 2.24 91/08/01 12:55:25 rsb 35 34
c 
e
s 00040/00000/00511
d D 2.23 91/08/01 10:56:10 rsb 34 33
c moved quit()
e
s 00020/00010/00491
d D 2.22 91/07/31 16:18:54 rsb 33 32
c establishing spatial
e
s 00053/00036/00448
d D 2.21 91/07/29 14:14:48 rsb 32 31
c converted to sp
e
s 00003/00003/00481
d D 2.20 91/07/29 11:31:40 rsb 31 30
c 
e
s 00425/00008/00059
d D 2.19 91/07/29 10:07:03 rsb 30 29
c major file reorganisation
e
s 00004/00016/00063
d D 2.18 91/07/28 22:28:05 rsb 29 28
c introduced mylloc and myfree
e
s 00002/00002/00077
d D 2.17 91/07/24 13:51:03 rsb 28 27
c 
e
s 00008/00001/00071
d D 2.16 91/07/24 13:35:01 rsb 27 26
c cext comments
e
s 00001/00001/00071
d D 2.15 91/07/08 11:49:07 rsb 26 25
c changed init to my_init
e
s 00001/00000/00071
d D 2.14 91/07/04 12:56:18 rsb 25 24
c inserted #ident
e
s 00005/00002/00066
d D 2.13 91/07/04 10:15:50 rsb 24 23
c restored ifdef for DOS
e
s 00003/00003/00065
d D 2.12 91/07/04 09:20:28 rsb 23 22
c #ifdefs removed
e
s 00002/00000/00066
d D 2.11 91/07/03 15:12:44 rsb 22 21
c  
e
s 00005/00000/00061
d D 2.10 91/07/03 12:03:05 rsb 21 20
c moved header files
e
s 00000/00000/00061
d D 2.9 91/07/03 09:58:57 rsb 20 19
c removed DOS condition on errno
e
s 00001/00001/00060
d D 2.8 91/07/03 09:46:49 rsb 19 18
c if SVAT | DOS
e
s 00002/00002/00059
d D 2.7 91/07/03 09:41:25 rsb 18 17
c DOS malloc.h, (long int)
e
s 00006/00004/00055
d D 2.6 91/07/02 15:31:16 rsb 17 16
c Inserted DEBUG and removed select
e
s 00015/00068/00044
d D 2.5 91/07/01 14:17:57 rsb 16 15
c Removed signals and edline
e
s 00000/00000/00112
d D 2.4 91/06/28 15:54:49 rsb 15 14
c 
e
s 00001/00001/00111
d D 2.3 91/06/20 11:44:03 rsb 14 13
c #ifdef SVAT of malloc, (int) cast of strlen()
e
s 00006/00023/00106
d D 2.2 91/06/20 11:18:24 rsb 13 12
c Integration of history mechanism
e
s 00010/00290/00119
d D 2.1 91/06/19 16:26:33 rsb 12 11
c Transfer to czech
e
s 00005/00001/00404
d D 1.11 90/10/28 19:57:24 rsb 11 10
c 
e
s 00035/00011/00370
d D 1.10 89/08/04 15:02:44 rsb 10 9
c 
e
s 00021/00002/00360
d D 1.9 89/06/02 11:31:22 rsb 9 8
c 
e
s 00013/00002/00349
d D 1.8 89/05/30 10:00:48 rsb 8 7
c 
e
s 00098/00078/00253
d D 1.7 89/05/29 15:58:53 rsb 7 6
c 
e
s 00002/00002/00329
d D 1.6 89/05/27 00:39:48 rsb 6 5
c 
e
s 00080/00012/00251
d D 1.5 89/05/18 09:18:40 rsb 5 4
c 
e
s 00000/00000/00263
d D 1.4 89/05/13 23:56:34 rsb 4 3
c 
e
s 00052/00059/00211
d D 1.3 89/05/12 15:13:41 rsb 3 2
c 
e
s 00172/00067/00098
d D 1.2 89/05/02 10:19:07 rsb 2 1
c 
e
s 00165/00000/00000
d D 1.1 89/03/17 11:58:59 rsb 1 0
c date and time created 89/03/17 11:58:59 by rsb
e
u
U
t
T
I 27
/* -------------------------------------------------------
D 28
FILE: main.c
Version: %W%
E 28
I 28
D 39
FILE: %M%
Version: %I% of %E% %U%
E 39
I 39
D 40
FILE: main_sp.c
Version: 2.27 of 91/08/06 13:15:37
E 40
I 40
FILE: %M%
Version: %I% of %E% %U%
E 40
E 39
E 28
D 30
This file contains only the top level program which manages
E 30
I 30
D 32
This file contains the top level INDEX program which manages
E 32
I 32
This file contains the top level SPATIAL program which manages
E 32
E 30
arguments if any and the entering of commands, together with the
D 30
history list.
E 30
I 30
history list, and program specific routines for initiation,
token recognition, and help functions.
I 42

Spatial - SYSTAT compatible module for spatial statistics
Copyright (C) 1990, 1991, 1992, Roger Bivand
E 42
E 30
--------------------------------------------------------- */
E 27
I 25
D 39
#ident "%W%"
E 39
I 39
D 40
#ident "@(#)main_sp.c	2.27"
E 40
I 40
#ident "%W%"
E 40
E 39
E 25
I 7
D 12
#ifdef CURSES

E 7
I 1
#include "cur.h"
I 7
D 10
#include "SysOut.h"
E 10
I 10
#include "sysout.h"
E 10

#else

E 12
#include <stdio.h>
#include <ctype.h>
#include <string.h>
I 12
D 13
#include <assert.h>
E 13
E 12

I 21
D 23
#ifdef DOS
E 23
I 23
D 24
#if DOS
E 24
I 24
D 30
#ifdef DOS
E 24
E 23
I 22
#include "defs.h"
E 22
E 21
D 12
#endif	/* CURSES */

E 12
D 10
#include "SysA.h"
E 10
I 10
#include "sysa.h"
I 21
#else
E 30
I 22
D 31
#include "../h/defs.h"
E 22
#include "../h/sysa.h"
E 31
I 31
#include "defs.h"
#include "sysa.h"
E 31
D 30
#endif
E 30

E 21
I 13
D 18
#ifdef SVAT
E 18
I 18
D 19
#ifdef SVAT | DOS
E 19
I 19
D 24
#if SVAT | DOS
E 24
I 24
D 29
#ifdef DOS
#include <malloc.h>
#endif
#if SVAT
E 24
E 19
E 18
E 13
E 10
E 7
I 5
#include <malloc.h>
I 13
#endif
E 13
I 10

E 29
D 16
#ifdef DOS
#include <signal.h>
#else
E 10
I 7
#include <sys/signal.h>
I 10
#endif

E 10
#define ERROR	(-1)
E 7
E 5

E 16
I 2
D 5
struct SysAction sys;
E 5
I 5
D 30
struct	SysAction sys;
E 30
I 12
D 16
extern char *edline();
E 16
D 13
#define BUFRSIZE 81
#define MAXSLOTS 50
char (*hist_buf)[BUFRSIZE] = (char (*)[BUFRSIZE])NULL;
int curslot = 0;
E 13
E 12
E 5
D 27

E 27
I 27
/* Main function managing program */
E 27
I 5
D 7
char	graph_buf[(GLINES+10)*GCHARA + 1];	/* graphics buffer */
int	gbuf_len;				/* its length */
E 7
I 7
main(argc, argv)
E 7

E 5
E 2
D 7
main()
E 7
I 7
int argc;
char *argv[];

E 7
{
I 30
	struct SysAction sys;
E 30
D 2
	int i, c, alert_flag, width_flag;
E 2
I 2
D 5
	int i, oc, c, alert_flag;
E 5
I 5
	int i, j, k, oc, c, alert_flag;
I 10

E 10
I 9
D 16
#ifdef SYSV
E 9
I 7
	int oldint;
I 9
#else
	int (*oldint)();
#endif
I 10

E 10
E 9
	void c_quit();

E 16
D 12
#ifndef CURSES
E 12
I 10
D 17
	char inbuf[BUFSIZ], *p;
E 17
I 17
D 29
	char inbuf[BUFSIZ];
E 29
I 29
	char inbuf[BUFSIZ], var[30];
	char *mylloc();
E 29
E 17
D 12
#ifndef DOS
	char *malloc();
#endif /* DOS */
#endif /* CURSES */
E 12
E 10

D 8
	char inbuf[BUFSIZ];
E 8
I 8
D 10
	char inbuf[BUFSIZ], *p, *malloc();
E 8

#endif
E 7
E 5
E 2
	
E 10
I 10
D 13
#ifndef DOS	
E 13
I 13
D 23
#ifdef SVAT
E 23
I 23
D 29
#if SVAT
E 23
E 13
E 10
I 5
	extern char *malloc();
D 10
	
E 10
I 10
D 13
#endif /* DOS */
E 13
I 13
#endif /* SVAT */
E 13

E 29
E 10
I 7
	if (argc > 2) {
		fprintf(stderr, "Usage: %s <command file>\n", argv[0]);
		exit(1);
	}
	
E 7
E 5
D 2
	initscr();
	nl();
	noecho();
	cbreak();
	raw();

	TERM  = newwin(LINES-4, COLS, 0, 0);
	STATUS  = newwin(1, COLS, LINES-2, 0);
/*	gr  = newwin(LINES-4, COLS-20, 0, 20); */
	COMMAND = newwin(1, COLS, LINES-1, 0);
	ALERT = newwin(1, COLS, LINES-3, 0);
	wattrset(STATUS, A_REVERSE);
/*	overwrite(gr, TERM);  */
E 2
I 2
	/* open and initialise windows, write banner */
E 2
	
D 2
	mvwprintw(TERM, 0, 0, "SYSTAT Compatible Programme");
	mvwprintw(TERM, 2, 0, "INDEX - Gini index and Lorentz curves");
	mvwprintw(TERM, 4, 0, "by Roger Bivand, Institute of Geography,");
	mvwprintw(TERM, 5, 0, "Norwegian School of Economics and Business Administration");
	mvwprintw(TERM, 6, 0, "Helleveien 30, N-5035 Bergen Sandviken");
	mvwprintw(TERM, 7, 0, "Telephone: +47-5-959355, e-mail: roger.bivand@nhh.uninett.ean");
	mvwprintw(TERM, 8, 0, "Copyright 1989");
	wnoutrefresh(TERM);
E 2
I 2
D 5
	alert_flag=init_index();	
E 5
I 5
D 7
	alert_flag=init_index();
E 7
I 7
D 12
	alert_flag=init_index(&sys);
E 12
I 12
D 26
	alert_flag=init(&sys);
E 26
I 26
	alert_flag=my_init(&sys);
E 26
D 13
	if( hist_buf == (char (*)[BUFRSIZE])NULL )
		assert( (hist_buf = (char (*)[BUFRSIZE])calloc(MAXSLOTS, BUFRSIZE)) != (char (*)[BUFRSIZE])NULL );
E 13
E 12
D 9
	
E 9
I 9

D 16
#ifdef SYSV
E 9
	if ((oldint = signal(SIGFPE, c_quit)) == ERROR) {
I 9
#else
	if ((oldint = signal(SIGFPE, c_quit)) == (int (*)()) ERROR) {
#endif
E 9
		perror(argv[0]);
		quit(&sys);
	}
I 10
#ifndef DOS
E 10
I 9
#ifdef SYSV
E 9
	if ((oldint = signal(SIGBUS, c_quit)) == ERROR) {
I 9
#else
	if ((oldint = signal(SIGBUS, c_quit)) == (int (*)()) ERROR) {
#endif
E 9
		perror(argv[0]);
		quit(&sys);
	}
I 10
#endif /* DOS */
E 10
I 9
#ifdef SYSV
E 9
	if ((oldint = signal(SIGSEGV, c_quit)) == ERROR) {
I 9
#else
	if ((oldint = signal(SIGSEGV, c_quit)) == (int (*)()) ERROR) {
#endif
E 9
		perror(argv[0]);
		quit(&sys);
	}
		
D 12
#ifndef CURSES
E 12
E 7
E 5
E 2
D 9

E 9
I 9
#ifdef SYSV
E 9
I 7
	if ((oldint = signal(SIGINT, c_quit)) == ERROR) {
I 9
#else
	if ((oldint = signal(SIGINT, c_quit)) == (int (*)()) ERROR) {
#endif
E 9
		perror(argv[0]);
		quit(&sys);
	}
D 12
#endif
E 12

E 16
	if (argc > 1) {
		alert_flag = set_submit(&sys, argc, argv);
D 12
#ifdef CURSES
		reffile(); wnoutrefresh(STATUS);
		mvwaddstr(COMMAND, 0, 0, PROMPT); wmove(COMMAND, 0, PP);
			wnoutrefresh(COMMAND);
		doupdate();
		eob = 0;
#endif
E 12
	}
	
E 7
D 2
	for (i=0; i<=STATUS->_maxx; i++) wprintw(STATUS, " ");
		wnoutrefresh(STATUS);
		
	werase(ALERT); wnoutrefresh(ALERT); alert_flag=0;

	mvwprintw(COMMAND, 0, 0, PROMPT); wmove(COMMAND, 0, PP);
		wnoutrefresh(COMMAND); eob = 0; width_flag=0;
	doupdate();

E 2
I 2
	/* begin command line character read loop */
	
E 2
	for(;;)
	{
I 7
D 12

#ifdef CURSES

E 7
		c=wgetch(COMMAND);
		switch(c) {
I 2
			case PREVIOUS:
				{
					static int count;
					if (oc == PREVIOUS) count++;
					else count = 0;
					alert_flag = previous(count);
					break;
				}
E 2
D 5
			case INTR:
E 5
I 5
			case INTR: {
E 5
D 3
				alert_flag=quit();
E 3
I 3
				alert_flag=quit(&sys);
E 3
				break;
I 5
				}
			case TOP:
			    {
				if (is_top == 0) {
					alert_flag = topg();
					if (alert_flag == 0) is_top = 1;
					else is_top = 0;
					break;
					}
				else {
					topt();
					is_top = 0;
					break;
				}
			    }
E 5
			case NEWLINE:
D 2
				alert_flag=newline(width_flag);
E 2
I 2
				alert_flag=newline();
E 2
				break;
			case BACKSPACE:
D 2
				if (COMMAND->_curx > PP) {
					mvwdelch(COMMAND, 0,
						(COMMAND->_curx-1));
					--eob;
				}
				else mvwdelch(COMMAND, 0, PP);
				refeob();
				wmove(COMMAND, 0, COMMAND->_curx);
				wnoutrefresh(COMMAND);
				doupdate();
E 2
I 2
				back_space();
E 2
				break;
			case STARTOL:
				wmove(COMMAND, 0, PP); wrefresh(COMMAND);
				break;
			case BACKWARD:
				if (COMMAND->_curx > PP) {
					wmove(COMMAND, 0, COMMAND->_curx-1);
					wrefresh(COMMAND);
				}
				break;
			case DELCHAR:
D 2
				if(COMMAND->_curx <= eob+PP) {
					if(COMMAND->_curx > PP ) {
						wdelch(COMMAND);
						--eob;
					}
					else wdelch(COMMAND);
				}
				refeob();
				wmove(COMMAND, 0, COMMAND->_curx);
				wnoutrefresh(COMMAND);
				doupdate();		
E 2
I 2
				del_char();
E 2
				break;
			case ENDOL:
				wmove(COMMAND, 0, eob+PP); wrefresh(COMMAND);
				break;
			case FORWARD:
				if (COMMAND->_curx < eob+PP) {
					wmove(COMMAND, 0, COMMAND->_curx+1);
					wrefresh(COMMAND);
				}
				break;
			case KILLCHAR:
				wclrtoeol(COMMAND);
				eob=COMMAND->_curx-PP;
D 3
				refeob();
E 3
				wmove(COMMAND, 0, COMMAND->_curx);
				wnoutrefresh(COMMAND);
				doupdate();
				break;
			default:
D 2
				width_flag=process(c, alert_flag, width_flag);
E 2
I 2
				process(c, alert_flag);
E 2
		}
I 2
D 7
	oc = c;
E 7
I 7
		oc = c;
#else
		printf("> ");
		if ((alert_flag = fgetline(inbuf, BUFSIZ, stdin))
			< 0) alert_flag = quit(&sys);
E 12
I 12
D 13
		strcpy(inbuf,edline("> "));
E 12
D 8
		alert_flag = xtok(inbuf, &sys);
E 8
I 8
		if (strlen(inbuf) > 0) {
			alert_flag = xtok(inbuf, &sys);
			if (sys._history < MAXLINES) {
				if ((p = malloc(strlen(inbuf) + 1)) == NULL)
					alert_flag = walert("Storage exceeded");
				else {
					strcpy(p, inbuf);
					sys.history[sys._history++] = p;
				}
			}
			else alert_flag = walert("... history disabled");
		}
E 8

E 13
I 13
D 16
		strcpy(inbuf, edline("> ", &sys));
D 14
		if (strlen(inbuf) > (size_t) 0) alert_flag = xtok(inbuf, &sys);
E 14
I 14
		if ((int) strlen(inbuf) > 0) alert_flag = xtok(inbuf, &sys);
E 16
I 16
		printf("> ");
		if ((alert_flag = fgetline(inbuf, BUFSIZ, stdin))
			< 0) alert_flag = quit(&sys);
		if ((int) strlen(inbuf) > 0) {
			alert_flag = xtok(inbuf, &sys);
			if (sys._history < MAXLINES) {
D 17
				if ((p = (char *) malloc((int) strlen(inbuf) + 1)) == NULL)
E 17
I 17
D 29
				if ((sys.history[sys._history] = (char *) malloc((int) strlen(inbuf) + 1)) == NULL)
E 29
I 29
				sprintf(var, "sys.history[%d]", sys._history);
				if ((sys.history[sys._history] = (char *) mylloc((unsigned int) strlen(inbuf) + 1, __LINE__, var, __FILE__)) == NULL)
E 29
E 17
					alert_flag = walert("Storage exceeded");
				else {
D 17
					strcpy(p, inbuf);
					sys.history[sys._history++] = p;
E 17
I 17
D 23
#ifdef DEBUG
E 23
I 23
D 29
#if DEBUG
E 23
D 18
					fprintf(stderr, "%s:%d\tsys.history[%d] = (char *) malloc(%d) at %d\n", __FILE__, __LINE__, sys._history, (int) strlen(inbuf) + 1, sys.history[sys._history]);
E 18
I 18
					fprintf(stderr, "%s:%d\tsys.history[%d] = (char *) malloc(%d) at %ld\n", __FILE__, __LINE__, sys._history, (int) strlen(inbuf) + 1, (long int) sys.history[sys._history]);
E 18
#endif
E 29
					strcpy(sys.history[sys._history++], inbuf);
E 17
				}
			}
			else alert_flag = walert("... history disabled");
		}
E 16
E 14
E 13
D 12
#endif
E 12
E 7
E 2
	}
}
I 30


#define MAXTOKENS	40		/* maximum number of tokens */
#define TLENGTH		70		/* maximum length of token */
#define RESERVED_CHARS	"_:.$()-"
					/* systat's reserved characters */
#define	QUOTES		"\"\'"		/* systat's string quotes */
#define NCMP		2		/* no of charcters compared */

#define BY	systok[0]		/* by */
#define SYSTEM	systok[1]		/* system shell */
#define FORMAT	systok[2]		/* format */
#define HELP	systok[3]		/* help */
#define HISTORY	systok[4]		/* history */
#define NAME	systok[5]		/* name */
#define NOTE	systok[6]		/* note */
#define OUTPUT	systok[7]		/* output */
#define PAGE	systok[8]		/* page */
#define QUIT	systok[9]		/* quit */
#define SELECT	systok[10]		/* select */
#define SUBMIT	systok[11]		/* submit */
#define USE	systok[12]		/* use */
#define WEIGHT	systok[13]		/* weight */
#define SAVE	systok[14]		/* save */
D 32
#define INDEX	systok[15]		/* index */
E 32
I 32
#define GETMAP	systok[15]		/* get map */
#define RUN	systok[16]		/* run compilation */
I 36
#define MODEL	systok[17]		/* model */
#define	ESTIMATE	systok[18]	/* estimate */
#define STATISTICS	systok[19]	/* statistics */
E 36
E 32

D 32
#define MAXTOK	16			/* last systok + 1 */
E 32
I 32
D 36
#define MAXTOK	17			/* last systok + 1 */
E 36
I 36
#define MAXTOK	20			/* last systok + 1 */
E 36
E 32


static char *systok[] = {
		"BY",
		"DO",
		"FO",
		"HE",
		"HI",
		"NA",
		"NO",
		"OU",
		"PA",
		"QU",
		"SE",
		"SU",
		"US",
		"WE",
		"SA",
D 32
		"IN"} ;	/* array of known commands */
E 32
I 32
		"GE",
D 36
		"RU"} ;	/* array of known commands */
E 36
I 36
		"RU",
		"MO",
		"ES",
		"ST"} ;	/* array of known commands */
E 36
E 32


/*
input buffer lexical splitting into tokens legal in systat, conversion of
all unquoted to upper case - filename protection needed - special reserved
D 31
characters given in xtok.h
E 31
I 31
characters given above.
E 31
*/
int xtok(inbuf, sa)

char inbuf[];

struct SysAction *sa;

{

	int i, here, j, alert_flag, flag, quote_flag;
	int inbuf_len=strlen(inbuf);
	unsigned len;
	int ntokens;		/* number of tokens + 1 (tokens[0] !!) */
	char *tokens[MAXTOKENS];	/* array of tokens */
	char token[TLENGTH], *p, comp[NCMP+1];
	char *mylloc();
	char var[30];
	for (ntokens=0, i=0; ntokens<MAXTOKENS && i<inbuf_len;) {
		for (here=i, quote_flag = -1; inbuf[here] != '\0'; here++) {
			flag = -1;
			if(strchr(QUOTES, inbuf[here]) != NULL) {
				if(quote_flag == -1) {
					quote_flag = here;
					continue;
				}
				else {
					flag = 0;
					break;
				}
			}
			if(quote_flag == -1) {
				if (isspace(inbuf[here])
					|| inbuf[here] == ',') {
					flag=0;
					break;
				}
				if (!isalnum(inbuf[here]))
					if (strchr(RESERVED_CHARS, inbuf[here])
						== NULL) {
					flag=1;
					break;
				}
			}
		}
		len = quote_flag == -1 ? here-i : (here-i)-1;
		if (len == 0 && flag == 1) len=1;
		if (len == 0 && flag == 0) {
			i=here+1;
			continue;
		}
		if (quote_flag == -1) for (j=0; j<len; j++)
			token[j] = (islower(inbuf[i+j]) ?
				toupper(inbuf[i+j]) : inbuf[i+j]);
		else for (j=quote_flag+1; j <= quote_flag+len+1; j++)
			token[j-(quote_flag+1)] = inbuf[j];
		token[len]='\0';
		sprintf(var, "tokens[%d]", ntokens);
		if ((tokens[ntokens] = (char *)mylloc(
			(unsigned int) (len+1) * sizeof(char),
			__LINE__, var, __FILE__)) == NULL) {
			alert_flag=walert("Storage exceeded");
			break;
		}
		else {
			if(here-i > 0 && flag == 1)i=here;
			else i=here+1;
			strcpy(tokens[ntokens++], token);
			alert_flag=0;
		}
	}
	if (ntokens >= MAXTOKENS)
		return(walert("Number of tokens exceeded"));
	if (ntokens == 0) return(0);
		/* act on the first two uppercase letters of the first token */
	strncpy(comp, tokens[0], NCMP);
	comp[NCMP] = '\0';
	if (strcmp(BY, comp) == 0)
		alert_flag = walert("By not supported in this module");
	else if (strcmp(SYSTEM, comp) == 0 || tokens[0][0] == '!')
		alert_flag = go_shell(sa, ntokens, tokens);
	else if (strcmp(FORMAT, comp) == 0)
		alert_flag = set_fmt(sa, ntokens, tokens);
	else if (strcmp(HELP, comp) == 0) 
		alert_flag = disp_help(ntokens, tokens, NCMP, MAXTOK);
	else if (strcmp(HISTORY, comp) == 0)
		alert_flag = disp_hist(sa);
	else if (strcmp(NAME, comp) == 0)
		alert_flag = wputname(sa);
	else if (strcmp(NOTE, comp) == 0)
		alert_flag = wnote(sa, ntokens, tokens);
	else if (strcmp(OUTPUT, comp) == 0)
		alert_flag = set_out(sa, ntokens, tokens);
	else if (strcmp(PAGE, comp) == 0)
		alert_flag = walert("Page not supported in this module");
	else if (strcmp(QUIT, comp) == 0) {
		for (i=ntokens-1; i >= 0; i--) {
			sprintf(var, "tokens[%d]", i);
			myfree(tokens[i], __LINE__, var, __FILE__);
		}
		alert_flag = quit(sa);
	}
	else if (strcmp(SAVE, comp) == 0)
		alert_flag = set_save(sa, ntokens, tokens);
	else if (strcmp(SELECT, comp) == 0)
		alert_flag = walert("Select not supported in this module");
	else if (strcmp(SUBMIT, comp) == 0)
		alert_flag = set_submit(sa, ntokens, tokens);
	else if (strcmp(USE, comp) == 0)
		alert_flag = opuse(ntokens, tokens, sa);
	else if (strcmp(WEIGHT, comp) == 0)
		alert_flag = walert("Weight not supported in this module");
D 32
	else if (strcmp(INDEX, comp) == 0)
		alert_flag = calc_index(sa, ntokens, tokens);
E 32
I 32
	else if (strcmp(GETMAP, comp) == 0)
D 44
		alert_flag = getmap(ntokens, tokens);
E 44
I 44
		alert_flag = getmap(sa, ntokens, tokens);
E 44
	else if (strcmp(RUN, comp) == 0)
		alert_flag = run(sa, ntokens, tokens);
I 36
	else if (strcmp(MODEL, comp) == 0)
		alert_flag = sel_model(sa, ntokens, tokens);
	else if (strcmp(ESTIMATE, comp) == 0)
		alert_flag = estimate(sa, ntokens, tokens);
D 37
/*	else if (strcmp(STATISTICS, comp) == 0)
		alert_flag = cliff_ord(sa, ntokens, tokens); */
E 37
I 37
	else if (strcmp(STATISTICS, comp) == 0)
		alert_flag = cliff_ord(sa, ntokens, tokens);
E 37
E 36
E 32
	else
		alert_flag = walert("No such command");
	for (i=ntokens-1; i >= 0; i--) {
		sprintf(var, "tokens[%d]", i);
		myfree(tokens[i], __LINE__, var, __FILE__);
	}
	return(alert_flag);
}


/* function to display help message */
disp_help(ntokens, tokens, ncmp, maxtok)

int ntokens, ncmp, maxtok;
char *tokens[];

{
	static char *help[] = {
"The BY command is not supported in this module.\n\
",
"The DOS or ! command gives access to a command shell of the\n\
operating system. DOS or ! by itself gives an interactive shell\n\
from which the user must exit in the usual way, while the command\n\
followed by a string, preferably quoted to avoid case sensitivity,\n\
causes that string to be executed as a command to the operating system,\n\
and control to be returned to this program on completion.\n\
",
"The FORMAT command determines the number of digits to the\n\
right of the decimal point in all numerical output. This\n\
number cannot be larger than 9 or less than 0. If FORMAT\n\
is not used, the standard value is 3.\n\
\n\
Examples are:\n\
\n\
FORMAT=5\n\
FORMAT=0\n\
D 33
FORMAT=6/ (print tiny numbers with exponents)\n\
E 33
I 33
FORMAT=6/UNDERFLOW (print tiny numbers with exponents)\n\
E 33
",
"Type HELP\n\
",
"The HISTORY command displays the commands you have given so far.\n\
",
"The NAME command displays the variables available to you in the\n\
open systat file.\n\
",
"The NOTE command writes a comment on your output.\n\
\n\
An example is:\n\
\n\
NOTE \'THIS IS A COMMENT.\'\n\
",
"The OUTPUT command routes output to the console, a file,\n\
or the printer.\n\
\n\
Its syntax is:\n\
\n\
OUTPUT		(sends subsequent output to console)\n\
OUTPUT <file>	(sends output to a file), e.g.\n\
OUTPUT FILE1	(sends output to FILE1.DAT)\n\
\n\
If your operating system is case sensitive, please use single quotes\n\
around the file name.\n\
",
"The PAGE command is not supported in this module.\n\
",
"QUIT returns you to the operating system.\n\
",
"The SELECT command is not supported in this module.\n\
",
"The SUBMIT command sends a command file to SYSTAT for\n\
processing as if you had typed the file from the console.\n\
This file must be in your directory of files, and must contain\n\
characters (not binary data).\n\
\n\
Its syntax is:\n\
\n\
SUBMIT <file>\n\
\n\
Examples are:\n\
\n\
SUBMIT COMMANDS (reads from file COMMANDS) \n\
SUBMIT NEWJOB (reads from file NEWJOB)\n\
\n\
If your operating system is case sensitive, please use single quotes\n\
around the file name.\n\
",
"The USE command reads the variables in a SYSTAT file.\n\
\n\
Its syntax is:\n\
\n\
USE <file>\n\
\n\
An example is:\n\
\n\
USE \'mydata.sys\' (reads from mydata.sys)\n\
\n\
If your operating system is case sensitive, please use single quotes\n\
around the file name.\n\
",
"The WEIGHT command is not supported in this module.\n\
",
D 32
"The SAVE command saves the sorted X and Y values from\n\
the first pair of variables into a SYSTAT file.\n\
\n\
E 32
I 32
"The SAVE command saves contiguity data and eigenvalues into\n\
a SYSTAT file.\n\
D 33
The variables saved are:\n\
E 33
I 33
The variables saved, in addition to those in a SYSTAT file in use, are:\n\
E 33
D 38
ID		zone identification number,\n\
E 38
MAPCARD		number of contiguities,\n\
MAPPTR		linked list pointer,\n\
MAPDIAG		inverse of number of contiguities,\n\
MAPEIGEN	standardised binary contiguity matrix eigenvalues,\n\
MAPLIST$	contiguities coded as characters in the range 33-212.\n\
E 32
Its syntax is:\n\
\n\
SAVE <file> [/SINGLE | DOUBLE,'<comment>']\n\
\n\
D 32
Examples are:\n\
E 32
I 32
Example:\n\
E 32
\n\
D 32
SAVE TEMP (saves values, percentages, and cumulative percentages\n\
	into TEMP)\n\
E 32
I 32
SAVE TEMP\n\
E 32
",
D 32
"The INDEX command calculates and reports the values of three\n\
measures of inequality. It is based on the comparison of pairs\n\
of variables containing measures of amounts of resource held by\n\
the subunits - the observations.\n\
E 32
I 32
"The GETMAP command initiates the map compilation process by\n\
reading the map data from <filename>. The data should be separated\n\
D 39
by blanks, tabs, or newlines, and should be ordered as follows:\n\
E 39
I 39
by blanks, tabs, or newlines, as follows:\n\
E 39
E 32
\n\
D 32
Its syntax is:\n\
E 32
I 32
<number of zones>\n\
<zone number> <number of contiguities>\n\
<contiguity 1> <contiguity 2> <...>\n\
...\n\
E 32
\n\
D 32
INDEX <variable>[,<variable>,<...>]*<variable>\n\
E 32
I 32
D 39
The total number of lines in the file should be (<number of zones> * 2) + 1.\n\
E 32
\n\
E 39
D 32
An example is:\n\
E 32
I 32
Example:\n\
E 32
\n\
D 32
INDEX MAJORITY*MINORITY\n\
E 32
I 32
GETMAP <filename>\n\
I 33
GETMAP <filename> /VERBOSE (to report on reading of input data)\n\
E 33
E 32
D 39
\n\
D 32
The Lorentz curve will be plotted if the command is qualifed\n\
as follows:\n\
\n\
INDEX MAJORITY*MINORITY / PLOT\n\
E 32
I 32
Note: when running under case sensitive operating systems it may be\n\
prudent to quote the filename - <\'filename\'>\n\
E 39
E 32
",
D 32
"The INDEX module produces three measures of inequality: the\n\
Gini index, the index of segregation, and the fair-share point.\n\
A Lorenz curve may also be plotted.\n\
E 32
I 32
"The RUN command compiles the contiguity data into a linked list,\n\
D 33
checks its internal consistency, and calculates the eigenvalues\n\
of a matrix similar to the standardised binary contiguity matrix.\n\
The precision for the tests on the results may be set by:\n\
	RUN /TOL=1e-6 (default 1.0e-5)\n\
E 33
I 33
checks its internal consistency, and if the EIGEN option is chosen,\n\
calculates the eigenvalues of a matrix similar to the standardised\n\
binary contiguity matrix.\n\
	RUN /EIGEN\n\
If a SYSTAT file is in use, RUN collects the contiguity data from that\n\
file, if it exists.\n\
E 33
If the SAVE command has been entered prior to RUN, the results will be\n\
D 33
saved as a SYSTAT file ready for merging with a SYSTAT observation file,\n\
possibly using ID to conduct a relational join.\n\
E 33
I 33
saved as a SYSTAT file merged with the SYSTAT file currently in use.\n\
E 33
",
I 36
"The MODEL command specifies the model to be estimated.\n\
\n\
Its form is:\n\
\n\
MODEL <VAR> = [CONSTANT +] <VAR> + <...> [+ <L(VAR)> + <L(...)>]\n\
					[/ERROR\n\
					  COMFAC\n\
					  OLS\n\
\n\
Implicit lags are constructed for ERROR and COMFAC models; use the\n\
L(VAR) notation for explicit lags. When the lagged dependent variable\n\
is a predictor, maximum likelihood estimation is used unless the OLS\n\
option is chosen.\n\
",
"The interim ESTIMATE command prepares a SYSTAT command file and SYSTAT\n\
D 39
data file in accordance with the current model specification for\n\
submission to the SYSTAT NONLIN module for maximum likelihood estimation\n\
using a Quasi-Newton algorithm.\n\
E 39
I 39
data file from the current model specification for\n\
submission to the SYSTAT NONLIN module for maximum likelihood estimation.\n\
E 39
\n\
Its form is:\n\
D 38
ESTIMATE [/ITER = <#>\n\
E 38
I 38
ESTIMATE /NONLIN [ITER = <#>\n\
E 38
	   TOL = <#.>]\n\
\n\
D 39
The options modify the default values of ITER = 50, TOL = 1.0E-4,\n\
where these correspond to the values used by NONLIN.\n\
\n\
The file name to be used will be the first unused NONLIN00 - N0NLIN99\n\
E 39
I 39
ITER = 50, TOL = 1.0E-4 by default.\n\
The file name will be the first unused NONLIN00 - N0NLIN99\n\
E 39
in the current working directory.\n\
",
D 38
"The STATISTICS command calculates and reports the value of the spatial\n\
autocorrelation statistic due to Moran and subsequently Cliff and Ord\n\
under randomisation.\n\
E 38
I 38
"The STATISTICS command calculates and reports the value of Moran's spatial\n\
autocorrelation statistic under both normality and randomisation\n\
assumptions. The /BINARY option permits the use of a binary contiguity\n\
matrix - otherwise a standardised contiguity matrix is used.\n\
E 38
\n\
Its syntax is:\n\
\n\
D 38
STATISTICS <variable> [,<variable>, <...>]\n\
E 38
I 38
STATISTICS <variable> [,<variable>, <...>] [/BINARY]\n\
E 38
\n\
D 38
It also reports the first order autocorrelation coefficient for the\n\
E 38
I 38
It also reports the first order autocorrelation coefficient \n\
and the Lagrange multiplier test statistic for the\n\
E 38
standardised binary weights matrix.\n\
",
E 36
"The SPATIAL module is used to construct a SYSTAT file of spatial\n\
D 36
unit contiguities and eigenvalues for use in the modelling of\n\
spatial dependence. Current limitations include a maximum number of\n\
contiguities of 12, single precision eigenvalue calculation and a\n\
maximum number of zones equal to 180.\n\
E 36
I 36
D 39
unit contiguities and eigenvalues. Current limitations include a\n\
maximum number of contiguities of 12, single precision eigenvalue\n\
calculation and a maximum number of zones equal to 180.\n\
E 39
I 39
unit contiguities and eigenvalues.\n\
E 39
E 36
E 32
\n\
I 36
D 39
It permits the estimation of a number of regression\n\
models taking spatial dependence into account, and the testing of OLS\n\
regression residuals for spatial autocorrelation.\n\
E 39
I 39
It also permits the estimation of a number of regression\n\
models taking spatial dependence into account, and the testing of\n\
variables for spatial autocorrelation.\n\
E 39
\n\
E 36
D 32
INDEX commands are:\n\
E 32
I 32
Commands used in the SPATIAL module are:\n\
E 32
\n\
D 32
INDEX\n\
USE\n\
E 32
I 32
D 36
GETMAP\n\
RUN\n\
E 36
I 36
GETMAP, RUN\n\
D 38
MODEL, ESTIMATE, CLIFF\n\
E 38
I 38
MODEL, ESTIMATE, STATISTICS\n\
E 38
E 36
E 32
SUBMIT, OUTPUT\n\
D 32
NOTE, FORMAT\n\
HELP, HISTORY, NAME\n\
BY, SELECT\n\
E 32
I 32
D 36
NOTE\n\
HELP, HISTORY\n\
E 36
I 36
NOTE, FORMAT, NAME, HELP, HISTORY\n\
E 36
E 32
QUIT\n\
D 36
SAVE\n\
E 36
I 36
USE, SAVE\n\
E 36
D 32
PAGE, WEIGHT (Not supported)\n\
E 32
\n\
For additional information about these commands, type\n\
HELP followed by the name of the command.\n\
",
D 32

E 32
"SCREEN - no editing of command line supported.\n\
"
};
	int i, choice = maxtok;
	if (ntokens > 1) {
		for (i=0; i < maxtok; i++) {
			if(strncmp(systok[i], tokens[1], ncmp) == 0) {
				choice = i;
				i = 0;
				break;
			}
		}
		if (strncmp("SCREEN", tokens[1], ncmp) == 0) {
			choice = maxtok + 1;
			i = 0;
		}
		if (choice == maxtok)
			i = walert("No help on this item");
	}
	else i = 0;
	printf("%s", help[choice]);
	return(i);
}


/* initialises the sys structure */
my_init(sa)

struct	SysAction *sa;

{
	int i;
	char tmp[2];

I 33
	printf("SYSTAT Compatible Programme\n\n");
E 33
	printf(
D 33
"SYSTAT Compatible Programme\n\n\
D 32
INDEX - Gini index and Lorentz curves\n\n\
E 32
I 32
SPATIAL - analysis and modelling of spatial dependence\n\n\
E 33
I 33
" #####  ######     #    #######   ###      #    #\n\
#     # #     #   # #      #       #      # #   #\n\
#       #     #  #   #     #       #     #   #  #\n\
 #####  ######  #     #    #       #    #     # #\n\
      # #       #######    #       #    ####### #\n\
#     # #       #     #    #       #    #     # #\n\
 #####  #       #     #    #      ###   #     # #######\n");
    printf(
"\nSPATIAL - analysis and modelling of spatial dependence\n\n\
E 33
E 32
by Roger Bivand, Institute of Geography,\n\
Norwegian School of Economics and Business Administration\n\
D 39
Helleveien 30, N-5035 Bergen Sandviken\n\
Telephone: +47-5-959355 Fax: +47-5-258383, e-mail: rsb@czech.nhh.no\n\
E 39
I 39
Breiviken 2, N-5035 Bergen Sandviken\n\
D 43
Telephone: +47-5-959355 Fax: +47-5-959393, e-mail: rsb@czech.nhh.no\n\
E 43
I 43
Telephone: +47-5-959355 Fax: +47-5-959393, e-mail: rsb@barsoom.nhh.no\n\
E 43
E 39
Copyright (C) Roger Bivand, All Rights Reserved\n\
D 39
Version %I% of: %E% %U%\n"
E 39
I 39
D 40
Version 2.27 of: 91/08/06 13:15:37\n"
E 40
I 40
D 41
Version %I% of: %E% %U%\n"
E 41
I 41
Version %I% of ###DATE###\n"
E 41
E 40
E 39
	);
	
	/* initialise SysAction */
	
	strcpy(sa->fmt, ".3f");
	sa->output = NULL;
	sa->submit = NULL;
	sa->_history = 0;
	sa->_save = 0;
	
	/* initialise use structure */
	
	init_use();
	
	return(0);
}

/* handles the opening of submit files and accompanying householding */
set_submit(sa, ntokens, tokens)

struct SysAction *sa;
int ntokens;
char *tokens[];

{

	int i, alert_flag;
	char inbuf[BUFSIZ];

	extern int errno, sys_nerr;
	extern char *sys_errlist[];
	
	if (ntokens == 1) return(walert("No file name stated"));
	if (sa->submit != NULL) {
		walert("No nesting of submitted command files allowed");
		quit(sa);
	}
	if (access(tokens[1], 04) != 0) return(walert((errno > sys_nerr) ? 
		"File access error" : sys_errlist[errno]));
	if ((sa->submit = fopen(tokens[1], "r")) == NULL)
		return(walert((errno > sys_nerr) ? "File access error" :
			sys_errlist[errno]));
	while(fgetline(inbuf, BUFSIZ, sa->submit) >= 0) {
		printf("Processing: %s\n", inbuf);

		alert_flag = xtok(inbuf, sa);		/* executes here */
		
		if (alert_flag != 0) {			/* kicks you back to
							interactive if error */
			if(fclose(sa->submit) != 0)return(walert(
				(errno > sys_nerr) ? "File access error" :
					sys_errlist[errno]));
			sa->submit = NULL;
			return(alert_flag);
		}
	}
	if(fclose(sa->submit) != 0)return(walert((errno > sys_nerr) ? 
		"File access error" : sys_errlist[errno]));
	sa->submit = NULL;
	return(0);
}	/* set_submit */

I 34
/*
function to handle exit from program, freeing resources and
closing files, interactively asks for confirmation
*/
int quit(sa)

struct SysAction *sa;

{
	int i, k;
	char c[2], var[30];
	
	if(sa->submit == NULL) {
		printf("quit: are you sure? ");
				/* if not submit file confirm quit */

		k = fgetline(c, 2, stdin);
		if (k < 0) k = 'y';
		else k = (int) c[0];
	}
	else k = 'y';
	if( k == 'y' || k == 'Y' ) {
		k = disp_hist(sa);
		if (sa->output != NULL) fclose(sa->output);
		if (sa->submit != NULL) fclose(sa->submit);
		for (i=0; i < sa->_history; i++) {
			sprintf(var, "sa->history[%d]", i);
			myfree(sa->history[i], __LINE__, var, __FILE__);
		}
		free_map(__LINE__, __FILE__);
		free_model(__LINE__, __FILE__);
		close_save(sa);
		closeuse();
		exit(0);
	}
	else {
		return(0);
	}
}	/* quit */

E 34
E 30
D 16

I 7
D 10
void c_quit(signo)
E 10
I 10
void c_quit(signo)		/* do this if signal received */
E 10

int signo;

{
	char tmp[40];
	int i;
	sprintf(tmp, "... exiting following signal %d ...", signo);
	i = walert(tmp);
	quit(&sys);
}

E 16
D 12
#ifdef CURSES
I 10
			/* functions to handle curses input and screen
			management */
E 10

E 7
I 2
int previous(count, alert_flag)
E 2

D 2
int newline(width_flag)
int width_flag;
E 2
I 2
int count, alert_flag;

E 2
{
I 2
	int here;
	here = sys._history - (1 + count);
	if (here < 0) {
		alert_flag = walert("No more history");
		eob = 0;
D 3
		refeob();
E 3
		wmove(COMMAND, 0, PP); wclrtoeol(COMMAND);
		wnoutrefresh(COMMAND);
		doupdate();
		return(alert_flag);
	}
	if (alert_flag != 0) {
		werase(ALERT); wnoutrefresh(ALERT);
		alert_flag=0;
	}
	wmove(COMMAND, 0, PP); wclrtoeol(COMMAND);
	eob = strlen(sys.history[here]);
	waddstr(COMMAND, sys.history[here]);
D 3
	refeob();
E 3
	wnoutrefresh(COMMAND);
	doupdate();
	return(0);
}
D 3
	
E 3

D 3
int newline()

{
E 2
	int i, k, alert_flag;
D 2
	char inbuf[BUFSIZ];
E 2
I 2
	char inbuf[BUFSIZ], *p, *malloc();
E 2
	
D 2
	for (i=PP; i<=eob+PP; i++) {
E 2
I 2
	for (i=PP; i <= eob + PP - 1; i++) {
E 2
		k=(A_CHARTEXT & mvwinch(COMMAND, 0, i));
		inbuf[i-PP]=k;
	}
D 2
	inbuf[eob+1]='\0';
	mvwprintw(STATUS, 0, 0, "%s", inbuf);
	for (i=eob+1; i<=STATUS->_maxx; i++)
E 2
I 2
	inbuf[eob]='\0';
	mvwprintw(STATUS, 0, 0, "Processing: %s", inbuf);
	for (i=STATUS->_curx; i<=STATUS->_maxx; i++)
E 2
		wprintw(STATUS, " ");
	wnoutrefresh(STATUS);
D 2
	if (eob > 0)alert_flag=xtok(inbuf);
	wmove(COMMAND, 0, PP); wclrtoeol(COMMAND);
		wnoutrefresh(COMMAND);
E 2
I 2
	wmove(COMMAND, 0, PP); wclrtoeol(COMMAND); wnoutrefresh(COMMAND);
E 2
	doupdate();
D 2
	eob=0;
E 2
I 2
	if (eob > 0) {
		alert_flag = xtok(inbuf, &sys);
		if (sys._history < MAXLINES) {
			if ((p = malloc(eob+1)) == NULL)
				alert_flag = walert("Storage exceeded");
			else {
				strcpy(p, inbuf);
				sys.history[sys._history++] = p;
			}
		}
		else alert_flag = walert("... history disabled");
	}
	wmove(COMMAND, 0, PP); wnoutrefresh(COMMAND);
	doupdate();
	eob = 0;
E 2
	return(alert_flag);
}

E 3
D 2
int process(c, alert_flag, width_flag)
E 2
I 2
int process(c, alert_flag)
E 2

D 2
int c, alert_flag, width_flag;
E 2
I 2
int c, alert_flag;
E 2

{
	if (alert_flag != 0) {
		werase(ALERT); wnoutrefresh(ALERT);
		alert_flag=0;
		wmove(COMMAND, 0, COMMAND->_curx);
		wnoutrefresh(COMMAND);
	}
	if (! isprint(c)) beep();
	else {
		if (eob+PP+1 < COMMAND->_maxx) {
			winsch(COMMAND, c);
D 3
			refeob();
E 3
D 11
			wmove(COMMAND, 0, COMMAND->_curx+1);
E 11
I 11
			wmove(COMMAND, 0, COMMAND->_curx
#ifndef DOS
			+1
#endif
			);
E 11
			eob++;
		}
		else {
			alert_flag=walert("width exceeded");
D 3
			refeob();
E 3
			wmove(COMMAND, 0, COMMAND->_curx);
		}
		wnoutrefresh(COMMAND);
	}
	doupdate();
	return(0);
}

D 3
refeob()

{
	mvwprintw(STATUS, 0, STATUS->_maxx-2, "%2d", eob+1);
	wnoutrefresh(STATUS);
I 2
}

E 3
D 7
init_index()
E 7

D 7
{
	int i;
I 3
	char tmp[2];
E 3
	
	initscr();	/* choice of curses routines */
	nl();
	noecho();
	cbreak();
	raw();

	/* open the necessary windows */
	
D 5
	TERM  = newwin(LINES-4, COLS, 0, 0);
E 5
I 5
	TERM  = newwin(GLINES, COLS, 0, 0);
E 5
	STATUS  = newwin(1, COLS, LINES-2, 0);
D 5
/*	gr  = newwin(LINES-4, COLS-20, 0, 20); */
E 5
	COMMAND = newwin(1, COLS, LINES-1, 0);
	ALERT = newwin(1, COLS, LINES-3, 0);
	
	/* set attributes */
	
	wattrset(STATUS, A_REVERSE);
	scrollok(TERM, TRUE);
	
	/* set attributes */
	
D 5
/*	overwrite(gr, TERM);  */
	
E 5
	/* write banner */
	
I 5

	strcpy(graph_buf, "The graphics window - toggle with ^T");
	is_top = 0;
		
E 5
D 3
	mvwprintw(TERM, 0, 0, "SYSTAT Compatible Programme");
	mvwprintw(TERM, 2, 0, "INDEX - Gini index and Lorentz curves");
	mvwprintw(TERM, 4, 0, "by Roger Bivand, Institute of Geography,");
	mvwprintw(TERM, 5, 0, "Norwegian School of Economics and Business Administration");
	mvwprintw(TERM, 6, 0, "Helleveien 30, N-5035 Bergen Sandviken");
	mvwprintw(TERM, 7, 0, "Telephone: +47-5-959355, e-mail: roger.bivand@nhh.uninett.ean");
	mvwprintw(TERM, 8, 0, "Copyright (C) 1989 Roger Bivand");
E 3
I 3
	mvwprintw(TERM, 0, 0, "SYSTAT Compatible Programme\n\n");
	wprintw(TERM, "INDEX - Gini index and Lorentz curves\n\n");
	wprintw(TERM, "by Roger Bivand, Institute of Geography,\n");
	wprintw(TERM, "Norwegian School of Economics and Business Administration\n");
	wprintw(TERM, "Helleveien 30, N-5035 Bergen Sandviken\n");
	wprintw(TERM, "Telephone: +47-5-959355, e-mail: roger.bivand@nhh.uninett.ean\n");
	wprintw(TERM, "Copyright (C) 1989 Roger Bivand\n");
E 3
	wnoutrefresh(TERM);
	
	/* initialise windows */
	
	for (i=0; i<=STATUS->_maxx; i++) wprintw(STATUS, " ");
		wnoutrefresh(STATUS);
		
	werase(ALERT); wnoutrefresh(ALERT);

	mvwprintw(COMMAND, 0, 0, PROMPT); wmove(COMMAND, 0, PP);
		wnoutrefresh(COMMAND); eob = 0;
		
	/* and write them to screen */
	
	doupdate();
	
	/* initialise SysAction */
	
D 6
	sys.by.bynvars = 0;
E 6
I 6
	sys.by.npairs = 0;
	sys.select.flag = 0;
E 6
D 3
	sys.format = 3;
E 3
I 3
	strcpy(sys.fmt, ".3f");
E 3
	sys.output = NULL;
D 6
	sys.select.selnvars = 0;
E 6
	sys.submit = NULL;
	sys._history = 0;
I 5
	sys.TERM_buf = NULL;
E 5
	
	return(0);
}

E 7
back_space()

{
	if (COMMAND->_curx > PP) {
		mvwdelch(COMMAND, 0,
			(COMMAND->_curx-1));
			--eob;
	}
	else mvwdelch(COMMAND, 0, PP);
D 3
	refeob();
E 3
	wmove(COMMAND, 0, COMMAND->_curx);
	wnoutrefresh(COMMAND);
	doupdate();
	return;
}

del_char()

{
	if(COMMAND->_curx <= eob+PP) {
		if(COMMAND->_curx > PP ) {
			wdelch(COMMAND);
			--eob;
		}
		else wdelch(COMMAND);
	}
D 3
	refeob();
E 3
	wmove(COMMAND, 0, COMMAND->_curx);
	wnoutrefresh(COMMAND);
	doupdate();
	return;
E 2
}
I 3


D 5
#include <malloc.h>

E 5
int newline()

{
	int i, k, alert_flag;
	char inbuf[BUFSIZ], *p;
I 10
#ifndef DOS
E 10
	extern char *malloc();
I 10
#endif
E 10
	
	for (i=PP; i <= eob + PP - 1; i++) {
		k=(A_CHARTEXT & mvwinch(COMMAND, 0, i));
		inbuf[i-PP]=k;
	}
	inbuf[eob]='\0';
D 10
	mvwprintw(STATUS, 0, 0, "Processing: %s", inbuf);
E 10
I 10
	wmove(STATUS, 0, 0);
	wprintw(STATUS, "Processing: %s", inbuf);
E 10
	for (i=STATUS->_curx; i<=STATUS->_maxx; i++)
		wprintw(STATUS, " ");
	reffile(); wnoutrefresh(STATUS);
D 5
	wmove(COMMAND, 0, PP); wclrtoeol(COMMAND); wnoutrefresh(COMMAND);
E 5
I 5
	wmove(COMMAND, 0, 0); wclrtoeol(COMMAND); wnoutrefresh(COMMAND);
I 10
	if (is_top == 1) {
		topt();
		is_top = 0;
	}
E 10
E 5
	doupdate();
	if (eob > 0) {
		alert_flag = xtok(inbuf, &sys);
		if (sys._history < MAXLINES) {
			if ((p = malloc(eob+1)) == NULL)
				alert_flag = walert("Storage exceeded");
			else {
				strcpy(p, inbuf);
				sys.history[sys._history++] = p;
			}
		}
		else alert_flag = walert("... history disabled");
	}
	reffile(); wnoutrefresh(STATUS);
D 5
	wmove(COMMAND, 0, PP); wnoutrefresh(COMMAND);
E 5
I 5
	mvwaddstr(COMMAND, 0, 0, PROMPT); wmove(COMMAND, 0, PP);
		wnoutrefresh(COMMAND);
E 5
	doupdate();
	eob = 0;
	return(alert_flag);
}


I 5
D 10
int topg()
E 10
I 10
int topg()		/* top graphics subwindow in TERM, save text
			in sys.term_buf */
E 10

{
	int j, k;
	
D 7
	if ((sys.TERM_buf = malloc((GLINES * COLS) + 1))
E 7
I 7
	if ((sys.term_buf = malloc((GLINES * COLS) + 1))
E 7
		== NULL) return(walert("Storage exceeded"));
		
	for (j=0; j < GLINES; j++) for (k=0; k < COLS; k++)
D 7
		sys.TERM_buf[(j*COLS)+k] = (A_CHARTEXT & mvwinch(TERM, j, k));
E 7
I 7
		sys.term_buf[(j*COLS)+k] = (A_CHARTEXT & mvwinch(TERM, j, k));
E 7
		
	touchwin(TERM); wnoutrefresh(TERM);
	GRAPH = subwin(TERM, GLINES, GCHARA, 0, TERM->_maxx - GCHARA);
	scrollok(GRAPH, TRUE);
	werase(GRAPH);
	mvwaddstr(GRAPH, 0, 0, graph_buf);
	wnoutrefresh(GRAPH);
	wmove(COMMAND, 0, COMMAND->_curx);
	wnoutrefresh(COMMAND);
	doupdate();
	return(0);
}


D 10
int topt()
E 10
I 10
int topt()			/* delete graphics subwindow i TERM, restore
				text */
E 10

{
	int j, k;
	
	delwin(GRAPH);
	scrollok(TERM, FALSE);
	werase(TERM); touchwin(TERM);
D 7
	if (sys.TERM_buf != NULL) {
E 7
I 7
	if (sys.term_buf != NULL) {
E 7
		for (j=0; j < GLINES; j++)
		    for (k=0; k < COLS; k++)
D 7
			mvwaddch(TERM, j, k, sys.TERM_buf[(j*COLS)+k]);
		free(sys.TERM_buf);
E 7
I 7
			mvwaddch(TERM, j, k, sys.term_buf[(j*COLS)+k]);
		free(sys.term_buf);
E 7
	}
D 7
	sys.TERM_buf = NULL;
E 7
I 7
	sys.term_buf = NULL;
E 7
	wnoutrefresh(TERM);
	scrollok(TERM, TRUE);
	wmove(COMMAND, 0, COMMAND->_curx);
	wnoutrefresh(COMMAND);
	doupdate();
	return(0);
}
I 7

#endif
E 12
E 7
E 5
E 3
E 1
